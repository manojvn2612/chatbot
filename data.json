[
  {
      "code": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr",
      "function_name": "bubble_sort",
      "docstring": "Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This pass through the list is repeated until the list is sorted.",
      "language": "python",
      "tags": ["sorting", "algorithm", "bubble sort"],
      "dataset": "sorting_algorithms"
  },
  {
      "code": "def bubble_sort_v2(data):\n    length = len(data)\n    for x in range(length):\n        for y in range(0, length-x-1):\n            if data[y] > data[y+1]:\n                data[y], data[y+1] = data[y+1], data[y]\n    return data",
      "function_name": "bubble_sort_v2",
      "docstring": "Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This pass through the list is repeated until the list is sorted.",
      "language": "python",
      "tags": ["sorting", "algorithm", "bubble sort"],
      "dataset": "sorting_algorithms"
  },
  {
      "code": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
      "function_name": "insertion_sort",
      "docstring": "Insertion Sort builds the sorted array  one element at a time by repeatedly picking the next element and inserting it into its correct position in the already sorted part of the array.",
      "language": "python",
      "tags": ["sorting", "algorithm", "insertion sort"],
      "dataset": "sorting_algorithms"
  },
  {
      "code": "def insertion_sort_v2(data):\n    for index in range(1, len(data)):\n        temp = data[index]\n        j = index - 1\n        while j >= 0 and temp < data[j]:\n            data[j + 1] = data[j]\n            j -= 1\n        data[j + 1] = temp\n    return data",
      "function_name": "insertion_sort_v2",
      "docstring": "Insertion Sort builds the sorted array  one element at a time by repeatedly picking the next element and inserting it into its correct position in the already sorted part of the array.",
      "language": "python",
      "tags": ["sorting", "algorithm", "insertion sort"],
      "dataset": "sorting_algorithms"
  },
  {
      "code": "def selection_sort(arr):\n    for i in range(len(arr)):\n        min_idx = i\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
      "function_name": "selection_sort",
      "docstring": "Selection Sort repeatedly selects the smallest element from the unsorted part of the list and swaps it with the first unsorted element, effectively growing the sorted portion of the list.",
      "language": "python",
      "tags": ["sorting", "algorithm", "selection sort"],
      "dataset": "sorting_algorithms"
  },
  {
      "code": "def selection_sort_v2(data):\n    for index in range(len(data)):\n        min_index = index\n        for j in range(index + 1, len(data)):\n            if data[j] < data[min_index]:\n                min_index = j\n        data[index], data[min_index] = data[min_index], data[index]\n    return data",
      "function_name": "selection_sort_v2",
      "docstring": "Selection Sort repeatedly selects the smallest element from the unsorted part of the list and swaps it with the first unsorted element, effectively growing the sorted portion of the list.",
      "language": "python",
      "tags": ["sorting", "algorithm", "selection sort"],
      "dataset": "sorting_algorithms"
  },
  {
      "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n\n        merge_sort(L)\n        merge_sort(R)\n\n        i = j = k = 0\n\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n    return arr",
      "function_name": "merge_sort",
      "docstring": "Merge Sort is a divide-and-conquer algorithm that recursively splits the list into halves, sorts each half, and then merges the sorted halves back together.",
      "language": "python",
      "tags": ["sorting", "algorithm", "merge sort"],
      "dataset": "sorting_algorithms"
  },
  {
      "code": "def merge_sort_v2(data):\n    if len(data) > 1:\n        mid = len(data) // 2\n        left_half = data[:mid]\n        right_half = data[mid:]\n\n        merge_sort_v2(left_half)\n        merge_sort_v2(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                data[k] = left_half[i]\n                i += 1\n            else:\n                data[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            data[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            data[k] = right_half[j]\n            j += 1\n            k += 1\n    return data",
      "function_name": "merge_sort_v2",
      "docstring": "Merge Sort is a divide-and-conquer algorithm that recursively splits the list into halves, sorts each half, and then merges the sorted halves back together.",
      "language": "python",
      "tags": ["sorting", "algorithm", "merge sort"],
      "dataset": "sorting_algorithms"
  },
  {
      "code": "def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[len(arr) // 2]\n        left = [x for x in arr if x < pivot]\n        middle = [x for x in arr if x == pivot]\n        right = [x for x in arr if x > pivot]\n        return quick_sort(left) + middle + quick_sort(right)",
      "function_name": "quick_sort",
      "docstring": "Quick Sort is a divide-and-conquer algorithm. It selects a 'pivot' element from the list, partitions the other elements into those less than the pivot and those greater, and then recursively sorts the sub-arrays.",
      "language": "python",
      "tags": ["sorting", "algorithm", "quick sort"],
      "dataset": "sorting_algorithms"
  },
  {
      "code": "def quick_sort_v2(data):\n    if len(data) <= 1:\n        return data\n    else:\n        pivot_element = data[len(data) // 2]\n        less_than_pivot = [x for x in data if x < pivot_element]\n        equal_to_pivot = [x for x in data if x == pivot_element]\n        greater_than_pivot = [x for x in data if x > pivot_element]\n        return quick_sort_v2(less_than_pivot) + equal_to_pivot + quick_sort_v2(greater_than_pivot)",
      "function_name": "quick_sort_v2",
      "docstring": "Quick Sort is a divide-and-conquer algorithm. It selects a 'pivot' element from the list, partitions the other elements into those less than the pivot and those greater, and then recursively sorts the sub-arrays.",
      "language": "python",
      "tags": ["sorting", "algorithm", "quick sort"],
      "dataset": "sorting_algorithms"
  }
]
